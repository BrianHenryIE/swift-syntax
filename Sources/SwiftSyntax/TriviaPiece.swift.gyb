%{
  # -*- mode: Swift -*-
  from gyb_syntax_support.Trivia import TRIVIAS
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From Trivia.swift.gyb.
//// Do Not Edit Directly!
//===------------------- Trivia.swift - Source Trivia Enum ----------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// A contiguous stretch of a single kind of trivia. The constituent part of
/// a `Trivia` collection.
///
/// For example, four spaces would be represented by
/// `.spaces(4)`
///
/// In general, you should deal with the actual Trivia collection instead
/// of individual pieces whenever possible.
public enum TriviaPiece {
% for trivia in TRIVIAS:
    /// ${trivia.comment}
%   if trivia.is_collection():
    case ${trivia.lower_name}s(Int)
%   else:
    case ${trivia.lower_name}(String)
%   end
% end
}

extension TriviaPiece: TextOutputStreamable {
  /// Prints the provided trivia as they would be written in a source file.
  ///
  /// - Parameter stream: The stream to which to print the trivia.
  public func write<Target>(to target: inout Target)
    where Target: TextOutputStream {
    func printRepeated(_ character: String, count: Int) {
      for _ in 0..<count { target.write(character) }
    }
    switch self {
% for trivia in TRIVIAS:
%   if trivia.is_collection():
%   joined = ''.join(trivia.swift_characters)
    case let .${trivia.lower_name}s(count):
      printRepeated("${joined}", count: count)
%   else:
    case let .${trivia.lower_name}(text):
      target.write(String(describing: text))
%   end
% end
    }
  }
}

extension TriviaPiece: CustomDebugStringConvertible {
  /// Returns a description used by dump.
  public var debugDescription: String {
    switch self {
% for trivia in TRIVIAS:
%   if trivia.is_collection():
    case .${trivia.lower_name}s(let data):
      return "${trivia.lower_name}s(\(data))"
%   else:
    case .${trivia.lower_name}(let name):
      return "${trivia.lower_name}(\(name))"
%   end
% end
    }
  }
}

extension Trivia {
% for trivia in TRIVIAS:

%   if trivia.is_collection():
%   joined = ''.join(trivia.swift_characters)
  /// Returns a piece of trivia for some number of '${joined}' characters.
  public static func ${trivia.lower_name}s(_ count: Int) -> Trivia {
    return [.${trivia.lower_name}s(count)]
  }

  /// Gets a piece of trivia for '${joined}' characters.
  public static var ${trivia.lower_name}: Trivia {
    return .${trivia.lower_name}s(1)
  }
%   else:
  /// Returns a piece of trivia for ${trivia.name}.
  public static func ${trivia.lower_name}(_ text: String) -> Trivia {
    return [.${trivia.lower_name}(text)]
  }
%   end
% end
}

extension TriviaPiece: Equatable {}

extension TriviaPiece {
  public var byteLength: Int {
    switch self {
% for trivia in TRIVIAS:
%   if trivia.is_new_line:
    case let .${trivia.lower_name}s(count):
      return count * ${trivia.characters_len()}
%   elif trivia.is_collection():
    case let .${trivia.lower_name}s(count):
      return count
%   else:
    case let .${trivia.lower_name}(text):
      return text.utf8.count
%   end
% end
    }
  }
}

/// Trivia piece for token RawSyntax.
public enum RawTriviaPiece {
% for trivia in TRIVIAS:
%   if trivia.is_collection():
    case ${trivia.lower_name}s(Int)
%   else:
    case ${trivia.lower_name}(StringRef)
%   end
% end

  static func make(arena: SyntaxArena, _ piece: TriviaPiece) -> RawTriviaPiece {
    switch piece {
% for trivia in TRIVIAS:
%   if trivia.is_collection():
    case let .${trivia.lower_name}s(count): return .${trivia.lower_name}s(count)
%   else:
    case let .${trivia.lower_name}(text): return .${trivia.lower_name}(arena.intern(text))
%   end
% end
    }
  }
}

extension RawTriviaPiece: TextOutputStreamable {
  public func write<Target: TextOutputStream>(to target: inout Target) {
    TriviaPiece(raw: self).write(to: &target)
  }
}

extension TriviaPiece {
  init(raw: RawTriviaPiece) {
    switch raw {
% for trivia in TRIVIAS:
%   if trivia.is_collection():
    case let .${trivia.lower_name}s(count): self = .${trivia.lower_name}s(count)
%   else:
    case let .${trivia.lower_name}(text): self = .${trivia.lower_name}(String(stringRef: text))
%   end
% end
    }
  }
}

extension RawTriviaPiece {
  public var byteLength: Int {
    switch self {
% for trivia in TRIVIAS:
%   if trivia.is_new_line:
    case let .${trivia.lower_name}s(count):
      return count * ${trivia.characters_len()}
%   elif trivia.is_collection():
    case let .${trivia.lower_name}s(count):
      return count
%   else:
    case let .${trivia.lower_name}(text):
      return text.count
%   end
% end
    }
  }
}


extension RawTriviaPiece {
  @_spi(RawSyntax)
  public static func fromRawValue(kind: UInt8, text: StringRef) -> RawTriviaPiece {
    switch kind {
% for trivia in TRIVIAS:
    case ${trivia.serialization_code}:
%   if trivia.is_collection():
      return .${trivia.lower_name}s(text.count / ${trivia.characters_len()})
%   else:
      return .${trivia.lower_name}(text)
%   end
% end
    default:
      fatalError("unexpected trivia piece kind \(kind)")
    }
  }
}
