%{
  from gyb_syntax_support import *
  # -*- mode: Swift -*-
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxFactory.swift.gyb.
//// Do Not Edit Directly!
//===------- SyntaxFactory.swift - Syntax Factory implementations ---------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// This file defines the SyntaxFactory, one of the most important client-facing
// types in lib/Syntax and likely to be very commonly used.
//
// Effectively a namespace, SyntaxFactory is never instantiated, but is *the*
// one-stop shop for making new Syntax nodes. Putting all of these into a
// collection of static methods provides a single point of API lookup for
// clients' convenience.
//
//===----------------------------------------------------------------------===//


public enum SyntaxFactory {
  @available(*, deprecated, message: "use pure token kind with 'tokenText' argument")
  public static func makeToken(_ kind: LegacyTokenKind, presence: SourcePresence,
                               leadingTrivia: Trivia = [],
                               trailingTrivia: Trivia = []) -> TokenSyntax {
    let (kind, text) = kind.plain
    if presence == .missing {
      let raw = RawTokenSyntax.makeBlank(arena: .default, tokenKind: kind).raw
      return TokenSyntax(data: SyntaxData(rootRaw: raw, arena: .default))
    }

    return makeToken(arena: .default, kind,
                     tokenText: text,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }


  public static func makeToken(
    arena: SyntaxArena = .default,
    _ tokenKind: TokenKind,
    tokenText: String = "",
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TokenSyntax {
    let raw = RawSyntax.makeMaterializedToken(
      arena: arena, kind: tokenKind,
      text: tokenText,
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
    return TokenSyntax(data: SyntaxData(rootRaw: raw, arena: arena))
  }

  public static func makeUnknownSyntax(
    arena: SyntaxArena = .default,
    tokens: [TokenSyntax]
  ) -> UnknownSyntax {
    let raw = RawSyntax.makeLayout(
      arena: arena, kind: .unknown, uninitializedCount: tokens.count) { buffer in
      _ = buffer.initialize(from: tokens.map { $0.raw })
    }
    return UnknownSyntax(data: SyntaxData(rootRaw: raw, arena: arena))
  }
}

/// MARK: Syntax Node Creation APIs

extension SyntaxFactory {

% for node in SYNTAX_NODES:

%   if node.is_base():
%     pass
%   elif node.children:
%     child_params = []
%     for child in node.children:
%         param_type = child.type_name
%         if child.is_optional:
%            param_type = param_type + "?"
%         child_params.append("%s: %s" % (child.swift_name, param_type))
%     child_params = ', '.join(child_params)
  public static func make${node.syntax_kind}(
    arena: SyntaxArena = .default, ${child_params}
  ) -> ${node.name} {
    let raw = RawSyntax.makeLayout(arena: arena, kind: .${node.swift_syntax_kind},
                                   uninitializedCount: ${len(node.children)}) { buffer in
      buffer.initialize(repeating: nil)
%     for idx, child in enumerate(node.children):
%       optional_mark = "?" if child.is_optional else ""
      buffer[${idx}] = ${child.swift_name + optional_mark}.raw
%     end
    }
    return ${node.name}(data: SyntaxData(rootRaw: raw, arena: arena))
  }
%   elif node.is_syntax_collection():
  public static func make${node.syntax_kind}(
    arena: SyntaxArena = .default, _ elements: [${node.collection_element_type}]
  ) -> ${node.name} {
    let raw = RawSyntax.makeLayout(arena: arena, kind: .${node.swift_syntax_kind}, uninitializedCount: elements.count) { buffer in
      _ = buffer.initialize(from: elements.map { $0.raw })
    }
    return ${node.name}(data: SyntaxData(rootRaw: raw, arena: arena))
  }
%   end

%   if not node.is_base():
  public static func makeBlank${node.syntax_kind}(arena: SyntaxArena = .default) -> ${node.name} {
    let raw = Raw${node.name}.makeBlank(arena: arena).raw
    return ${node.name}(data: SyntaxData(rootRaw: raw, arena: arena))
  }
%   end
% end
}

/// MARK: Token Creation APIs

extension SyntaxFactory {
%{
  def token_trivia(requires_space):
    return '[.spaces(1)]' if requires_space else '[]'
}%

% for token in SYNTAX_TOKENS:
%   leading_trivia = token_trivia(token.requires_leading_space)
%   trailing_trivia = token_trivia(token.requires_trailing_space)
%   if token.is_keyword:
  public static func make${token.name}Keyword(
    arena: SyntaxArena = .default,
    leadingTrivia: Trivia = ${leading_trivia},
    trailingTrivia: Trivia = ${trailing_trivia}
  ) -> TokenSyntax {
    return makeToken(
      arena: arena, .${token.swift_kind()}, tokenText: "${token.text}",
      leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia)
  }
%   elif token.text:
  public static func make${token.name}Token(
    arena: SyntaxArena = .default,
    leadingTrivia: Trivia = ${leading_trivia},
    trailingTrivia: Trivia = ${trailing_trivia}
  ) -> TokenSyntax {
    return makeToken(
      arena: arena, .${token.swift_kind()}, tokenText: "${token.text}",
      leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia)
  }
%   else:
  public static func make${token.name}(
    arena: SyntaxArena = .default,
    _ text: String,
    leadingTrivia: Trivia = ${leading_trivia},
    trailingTrivia: Trivia = ${trailing_trivia}
  ) -> TokenSyntax {
    return makeToken(
      arena: arena, .${token.swift_kind()}, tokenText: text,
      leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia)
  }
%   end
% end
}


/// MARK: Convenience APIs

extension SyntaxFactory {

  public static func makeVoidTupleType(arena: SyntaxArena = .default) -> TupleTypeSyntax {
    return makeTupleType(
      arena: arena,
      leftParen: makeLeftParenToken(arena: arena),
      elements: makeBlankTupleTypeElementList(arena: arena),
      rightParen: makeRightParenToken(arena: arena))
  }

  public static func makeTupleTypeElement(
    arena: SyntaxArena = .default,
    name: TokenSyntax?,
    colon: TokenSyntax?,
    type: TypeSyntax,
    trailingComma: TokenSyntax?) -> TupleTypeElementSyntax {
    return makeTupleTypeElement(
      arena: arena, inOut: nil, name: name, secondName: nil, colon: colon,
      type: type, ellipsis: nil, initializer: nil, trailingComma: trailingComma)
  }

  public static func makeTupleTypeElement(
    arena: SyntaxArena = .default,
    type: TypeSyntax,
    trailingComma: TokenSyntax?
  ) -> TupleTypeElementSyntax  {
    return makeTupleTypeElement(
    arena: arena, name: nil, colon: nil, type: type, trailingComma: trailingComma)
  }

  public static func makeGenericParameter(
    arena: SyntaxArena = .default,
    name: TokenSyntax,
    trailingComma: TokenSyntax
  ) -> GenericParameterSyntax {
    return makeGenericParameter(
      arena: arena, attributes: nil, name: name, colon: nil,
      inheritedType: nil, trailingComma: trailingComma)
  }

  public static func makeTypeIdentifier(
    arena: SyntaxArena = .default,
    _ name: String,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TypeSyntax {
    let identifier = makeIdentifier(
      arena: arena,
      name,
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
    let typeIdentifier = makeSimpleTypeIdentifier(arena: arena,
                                                  name: identifier,
                                                  genericArgumentClause: nil)
    return TypeSyntax(typeIdentifier)
  }

  public static func makeAnyTypeIdentifier(
    arena: SyntaxArena = .default,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TypeSyntax {
    return makeTypeIdentifier(
      arena: arena,
      "Any",
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
  }

  public static func makeSelfTypeIdentifier(
    arena: SyntaxArena = .default,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TypeSyntax {
    return makeTypeIdentifier(
      arena: arena,
      "Self",
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
  }

  public static func makeTypeToken(
    arena: SyntaxArena = .default,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TokenSyntax {
    return makeIdentifier(
      arena: arena,
      "Type",
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
  }

  public static func makeProtocolToken(
    arena: SyntaxArena = .default,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TokenSyntax {
    return makeIdentifier(
      arena: arena,
      "Protocol",
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
  }

  public static func makeBinaryOperator(
    arena: SyntaxArena = .default,
    _ name: String,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> TokenSyntax {
    return makeToken(
      arena: arena,
      .spacedBinaryOperator,
      tokenText: name,
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
  }

  public static func makeStringLiteralExpr(
    arena: SyntaxArena = .default,
    _ text: String,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> StringLiteralExprSyntax {
    let string = makeStringSegment(arena: arena, text)
    let segment = makeStringSegment(arena: arena, content: string)
    let segments = makeStringLiteralSegments(arena: arena, [Syntax(segment)])
    let openQuote = makeStringQuoteToken(arena: arena, leadingTrivia: leadingTrivia)
    let closeQuote = makeStringQuoteToken(arena: arena, trailingTrivia: trailingTrivia)
    return makeStringLiteralExpr(arena: arena, openDelimiter: nil,
                                 openQuote: openQuote,
                                 segments: segments,
                                 closeQuote: closeQuote,
                                 closeDelimiter: nil)
  }

  public static func makeVariableExpr(
    arena: SyntaxArena = .default,
    _ text: String,
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = []
  ) -> IdentifierExprSyntax {
    let string = makeIdentifier(arena: arena, text,
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia)
    return makeIdentifierExpr(arena: arena, identifier: string,
                              declNameArguments: nil)
  }
}
