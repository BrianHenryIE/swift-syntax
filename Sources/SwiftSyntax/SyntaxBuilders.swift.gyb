%{
  # -*- mode: Swift -*-
  from gyb_syntax_support import *
  NODE_MAP = create_node_map()
  # Ignore the following admonition; it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxBuilders.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxBuilders.swift - Syntax Builder definitions -------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
"""
A builder is a struct with a mutable layout inside. Clients can
specify as many or as few of the children as they want, and the structure is
guaranted to be structurally (if not syntactically) valid.
"""
}%

% for node in SYNTAX_NODES:
%   if node.is_buildable():
%     Builder = node.name + "Builder"
public struct ${Builder} {
  private var layout: [RawSyntax?] = .init(repeating: nil, count: ${len(node.children)})
  private var arena: SyntaxArena

  internal init(arena: SyntaxArena) { self.arena = arena }
%     for child in node.children:
%       child_node = NODE_MAP.get(child.syntax_kind)
%       if child_node and child_node.is_syntax_collection():
%         child_elt = child.collection_element_name
%         child_elt_type = child_node.collection_element_type
%         if not child_elt:
%           raise Exception("'collection_element_name' should be set for '%s' of '%s'" % (child.name, node.name))
%         end

  public mutating func add${child_elt}(_ elt: ${child_elt_type}) {
    let idx = ${node.name}.Cursor.${child.swift_name}.rawValue
    if let list = layout[idx] {
      layout[idx] = list.insertingChild(elt.raw, at: list.children.count, arena: arena)
    } else {
      layout[idx] = RawSyntax.makeLayout(arena: arena, kind: .${child_node.swift_syntax_kind}, uninitializedCount: 1) { buffer in
        buffer.baseAddress!.initialize(to: elt.raw)
      }
    }
  }
%       else:

  public mutating func use${child.name}(_ node: ${child.type_name}) {
    let idx = ${node.name}.Cursor.${child.swift_name}.rawValue
    layout[idx] = node.raw
  }
%       end
%     end

  internal mutating func buildData() -> SyntaxData {
%     for (idx, child) in enumerate(node.children):
%       if not child.is_optional:
    if (layout[${idx}] == nil) {
%         if child.is_token():
%           token = child.main_token()
%           tok_kind = token.swift_kind() if token else "unknown"
      layout[${idx}] = Raw${child.type_name}.makeBlank(arena: arena, tokenKind: .${tok_kind}).raw
%         else:
      layout[${idx}] = Raw${child.type_name}.makeBlank(arena: arena).raw
%         end
    }
%       end
%     end

    let raw = RawSyntax.makeLayout(arena: arena, kind: .${node.swift_syntax_kind},
                                   uninitializedCount: ${len(node.children)}) { buffer in
      _ = buffer.initialize(from: layout)
    }

    return SyntaxData(rootRaw: raw, arena: arena)
  }
}

extension ${node.name} {
  /// Creates a `${node.name}` using the provided build function.
  /// - Parameter:
  ///   - build: A closure that will be invoked in order to initialize
  ///            the fields of the syntax node.
  ///            This closure is passed a `${Builder}` which you can use to
  ///            incrementally build the structure of the node.
  /// - Returns: A `${node.name}` with all the fields populated in the builder
  ///            closure.
  public init(arena: SyntaxArena = .default, _ build: (inout ${Builder}) -> Void) {
    var builder = ${Builder}(arena: arena)
    build(&builder)
    let data = builder.buildData()
    self.init(data: data)
  }
}

%   end
% end
